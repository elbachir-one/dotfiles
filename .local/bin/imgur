#!/usr/bin/env bash

initialize() {
	declare -g -r CURRENT_VERSION="v2.0.0"

	declare -r CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
	if [ -f "${CONFIG_HOME}/user-dirs.dirs" ]; then
		source "${CONFIG_HOME}/user-dirs.dirs"
	fi

	declare -g -r CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/imgur"
	declare -g -r SETTINGS_PATH="${CONFIG_DIR}/settings.conf"
	declare -g ACCESS_TOKEN REFRESH_TOKEN TOKEN_EXPIRE_TIME

	declare -g -a UPLOAD_FILES

	load_default_config
	if [ -f "${SETTINGS_PATH}" ]; then
		source "${SETTINGS_PATH}"
	fi
}

load_default_config() {
	declare -g CLIENT_ID="ea6c0ef2987808e"
	declare -g CLIENT_SECRET="5ef4d4efcab40469a62fb2c2f1c9940360f6e504"
	declare -g CREDENTIALS_FILE="${CONFIG_DIR}/credentials.conf"
	declare -g FILE_NAME_FORMAT="imgur-%Y_%m_%d-%H:%M:%S.png"
	declare -g FILE_DIR="${XDG_PICTURES_DIR:-$HOME/Images/Shots}"
	declare -g IMGUR_ICON_PATH="${FILE_DIR}/imgur.png"
	declare -g NOTIFY_TIME="5000"
	declare -g UPLOAD_CONNECT_TIMEOUT="5"
	declare -g UPLOAD_TIMEOUT="120"
	declare -g UPLOAD_RETRIES="1"

	if is_mac; then
		declare -g SCREENSHOT_SELECT_COMMAND="screencapture -i %img"
		declare -g SCREENSHOT_WINDOW_COMMAND="screencapture -iWa %img"
		declare -g SCREENSHOT_FULL_COMMAND="screencapture %img"
		declare -g OPEN_COMMAND="open %url"
		declare -g CLIPBOARD_COMMAND="pbcopy"
	else
		declare -g SCREENSHOT_SELECT_COMMAND="scrot -s %img"
		declare -g SCREENSHOT_WINDOW_COMMAND="scrot -s -b %img"
		declare -g SCREENSHOT_FULL_COMMAND="scrot %img"
		declare -g OPEN_COMMAND="xdg-open %url"
		declare -g CLIPBOARD_COMMAND="xclip -selection clipboard"
	fi

	declare -g EXIT_ON_ALBUM_CREATION_FAIL="true"
	declare -g LOG_FILE="${CONFIG_DIR}/imgur-screenshot.log"
	declare -g COPY_URL="true"
	declare -g CHECK_UPDATE="true"
	declare -g LOGIN="false"
	declare -g ALBUM_TITLE
	declare -g ALBUM_ID
	declare -g OPEN="false"
	if [ "${BASH_VERSINFO[0]}" -ge "4" ]; then
		declare -g -u MODE="SELECT"
	else
		declare -g MODE="SELECT"
	fi
	declare -g EDIT_COMMAND="gimp %img"
	declare -g EDIT="false"
	declare -g AUTO_DELETE
	declare -g KEEP_FILE="true"
}

parse_args() {
	while [ ${#} != 0 ]; do
		case "${1}" in
			-h | --help)
				echo "usage: ${0} [--debug] [-c | -v | -h | -u]"
				exit 0;;
			-v | --version)
				echo "imgur-screenshot ${CURRENT_VERSION}"
				exit 0;;
			-c | --connect)
				load_access_token
				fetch_account_info
				exit 0;;
			-s | --select)
				MODE="SELECT"
				shift;;
			-w | --window)
				MODE="WINDOW"
				shift;;
			-f | --full)
				MODE="FULL"
				shift;;
			-o | --open)
				OPEN="${2}"
				shift 2;;
			-e | --edit)
				EDIT="${2}"
				shift 2;;
			-i | --edit-command)
				EDIT_COMMAND="${2}"
				EDIT="true"
				shift 2;;
			-l | --login)
				LOGIN="${2}"
				shift 2;;
			-a | --album)
				ALBUM_TITLE="${2}"
				shift 2;;
			-A | --album-id)
				ALBUM_ID="${2}"
				shift 2;;
			-k | --keep-file)
				KEEP_FILE="${2}"
				shift 2;;
			-d | --auto-delete)
				AUTO_DELETE="${2}"
				shift 2;;
			-u | --update)
				check_for_update
				exit 0;;
			*)
				UPLOAD_FILES=("${@}")
				break;;
		esac || { echo "Failed to parse options" >&2 && exit 1; }
	done
}

check_config() {
	local vars

	vars=(UPLOAD_CONNECT_TIMEOUT UPLOAD_RETRIES UPLOAD_TIMEOUT FILE_NAME_FORMAT FILE_DIR LOG_FILE)
	if [ "${LOGIN}" = "true" ]; then
		vars+=(CREDENTIALS_FILE)
	else
		vars+=(CLIENT_ID)
	fi

	for var in "${vars[@]}"; do
		if [ -z "${!var}" ]; then
			echo "ERROR: Config option $var is not set"
			exit 1
		fi
	done
}

main() {
	check_config
	check_oauth2_client_secrets

	if [ "${LOGIN}" = "true" ]; then
		load_access_token
	fi

	if [ -n "${ALBUM_TITLE}" ]; then
		create_album
	fi

	if [ -z "${UPLOAD_FILES[0]}" ]; then
		UPLOAD_FILES[0]=""
	fi

	for upload_file in "${UPLOAD_FILES[@]}"; do
		handle_file "${upload_file}"
	done

	if [ "${CHECK_UPDATE}" = "true" ]; then
		check_for_update
	fi
}

debug_mode() {
	echo "########################################"
	echo "Enabling debug mode"
	echo "Please remove credentials before pasting"
	echo "########################################"
	echo ""
	uname -a
	for arg in ${0} "${@}"; do
		echo -n "'${arg}' "
	done
	echo ""
	set -o xtrace
}

is_mac() {
	[ "$(uname -s)" = "Darwin" ]
}

notify() {
	if is_mac; then
		if command -v growlnotify &>/dev/null; then
			growlnotify  --icon "${IMGUR_ICON_PATH}" --iconpath "${IMGUR_ICON_PATH}" --title "${2}" --message "${3}"
		else
			terminal-notifier -appIcon "${IMGUR_ICON_PATH}" -contentImage "${IMGUR_ICON_PATH}" -title "imgur: ${2}" -message "${3}"
		fi
	else
		if [ "${1}" = "error" ]; then
			notify-send -a ImgurScreenshot -u critical -c "im.error" -i "${IMGUR_ICON_PATH}" -t "${NOTIFY_TIME}" "imgur: ${2}" "${3}"
		else
			notify-send -a ImgurScreenshot -u low -c "transfer.complete" -i "${IMGUR_ICON_PATH}" -t "${NOTIFY_TIME}" "imgur: ${2}" "${3}"
		fi
	fi
}

take_screenshot() {
	local cmd shot_err

	echo "Please select area"
	is_mac || sleep 0.1

	cmd="SCREENSHOT_${MODE}_COMMAND"
	cmd=${!cmd//\%img/${1}}

	if [ -z "${cmd}" ]; then
		echo "Warning: SCREENSHOT_${MODE}_COMMAND is empty (MODE=${MODE})"
		cmd=false
	fi

	shot_err="$(${cmd} 2>&1)"
	if [ "${?}" != "0" ]; then
		echo "$(date +'%FT%T%z')"$'\t'"Failed to take screenshot '${1}': '${shot_err}'." | tee -a "${LOG_FILE}"
		notify error "Something went wrong :(" "Information has been logged"
		exit 1
	fi
}

check_for_update() {
	local remote_version

	remote_version="$(set -o pipefail; curl --compressed -fsSL --stderr - "https://api.github.com/repos/jomo/imgur-screenshot/releases" | jq -r 'first(.[] | select(.prerelease == false).tag_name)')"
	if [ "${?}" -eq "0" ]; then
		if [ ! "${CURRENT_VERSION}" = "${remote_version}" ] && [ ! -z "${CURRENT_VERSION}" ] && [ ! -z "${remote_version}" ]; then
			echo "Update found!"
			echo "Version ${remote_version} is available (You have ${CURRENT_VERSION})"
			notify ok "Update found" "Version ${remote_version} is available (You have ${CURRENT_VERSION}). https://github.com/jomo/imgur-screenshot"
			echo "Check https://github.com/jomo/imgur-screenshot/releases/${remote_version} for more info."
		elif [ -z "${CURRENT_VERSION}" ] || [ -z "${remote_version}" ]; then
			echo "Invalid empty version string"
			echo "Current (local) version: '${CURRENT_VERSION}'"
			echo "Latest (remote) version: '${remote_version}'"
		else
			echo "Version ${CURRENT_VERSION} is up to date."
		fi
	else
		echo "Failed to check for latest version: ${remote_version}"
	fi
}

check_oauth2_client_secrets() {
	if [ -z "${CLIENT_ID}" ] || [ -z "${CLIENT_SECRET}" ]; then
		echo "Your CLIENT_ID and CLIENT_SECRET are not set."
		exit 1
	fi
}

load_access_token() {
	local current_time preemptive_refresh_time expired

	TOKEN_EXPIRE_TIME=0
	if [ -f "${CREDENTIALS_FILE}" ]; then
		source "${CREDENTIALS_FILE}"
	fi

	if [ ! -z "${REFRESH_TOKEN}" ]; then
		current_time="$(date +%s)"
		preemptive_refresh_time="600"
		expired=$((current_time > (TOKEN_EXPIRE_TIME - preemptive_refresh_time)))
		if [ "${expired}" -eq "1" ]; then
			refresh_access_token
		fi
	else
		acquire_access_token
		save_access_token
	fi
}

acquire_access_token() {
	local url params param_name param_value

	echo "You need to authorize imgur-screenshot to upload images. Please visit"
	echo "https://api.imgur.com/oauth2/authorize?client_id=${CLIENT_ID}&response_type=token"
	sleep 5
	echo "Paste the URL here:"

	read -r url
	if [[ ! "${url}" =~ "access_token=" ]]; then
		echo "ERROR: That URL doesn't look right, please try again"
		exit 1
	fi
	url="$(echo "${url}" | cut -d "#" -f 2-)"
	params=(${url//&/ })

	for param in "${params[@]}"; do
		param_name="$(echo "${param}" | cut -d "=" -f 1)"
		param_value="$(echo "${param}" | cut -d "=" -f 2-)"
		case "${param_name}" in
			access_token)
				ACCESS_TOKEN="${param_value}";;
			refresh_token)
				REFRESH_TOKEN="${param_value}";;
			expires_in)
				TOKEN_EXPIRE_TIME=$(( $(date +%s) + param_value ))
		esac
	done
	if [ -z "${ACCESS_TOKEN}" ] || [ -z "${REFRESH_TOKEN}" ] || [ -z "${TOKEN_EXPIRE_TIME}" ]; then
		echo "ERROR: Failed parsing the URL"
		exit 1
	fi
	save_access_token
}

save_access_token() {
	mkdir -p "$(dirname "${CREDENTIALS_FILE}")" 2>/dev/null
	touch "${CREDENTIALS_FILE}" && chmod 600 "${CREDENTIALS_FILE}"
	cat <<EOF > "${CREDENTIALS_FILE}"
ACCESS_TOKEN="${ACCESS_TOKEN}"
REFRESH_TOKEN="${REFRESH_TOKEN}"
TOKEN_EXPIRE_TIME="${TOKEN_EXPIRE_TIME}"
EOF
}

refresh_access_token() {
	local token_url response expires_in

	token_url="https://api.imgur.com/oauth2/token"
	response="$(curl --compressed -fsSL --stderr - -F "client_id=${CLIENT_ID}" -F "client_secret=${CLIENT_SECRET}" -F "grant_type=refresh_token" -F "refresh_token=${REFRESH_TOKEN}" "${token_url}")"
	if [ ! "${?}" -eq "0" ]; then
		handle_upload_error "${response}" "${token_url}"
		exit 1
	fi

	if ! jq -re .access_token >/dev/null <<<"${response}"; then
		echo "Error: Something is wrong with your credentials:"
		echo "${response}"
		exit 1
	fi

	ACCESS_TOKEN="$(jq -r .access_token <<<"${response}")"
	REFRESH_TOKEN="$(jq -r .refresh_token <<<"${response}")"
	expires_in="$(jq -r .expires_in <<<"${response}")"
	TOKEN_EXPIRE_TIME=$(( $(date +%s) + expires_in ))

	save_access_token
}

fetch_account_info() {
	local response username

	response="$(curl --compressed --connect-timeout "${UPLOAD_CONNECT_TIMEOUT}" -m "${UPLOAD_TIMEOUT}" --retry "${UPLOAD_RETRIES}" -fsSL --stderr - -H "Authorization: Bearer ${ACCESS_TOKEN}" https://api.imgur.com/3/account/me)"
	if [ "${?}" -eq "0" ] && [ "$(jq -r .success <<<"${response}")" = "true" ]; then
		username="$(jq -r .data.url <<<"${response}")"
		echo "Logged in as ${username}."
	else
		echo "Failed to fetch info: ${response}"
	fi
}

delete_image() {
	local response

	response="$(curl --compressed -X DELETE  -fsSL --stderr - -H "Authorization: Client-ID ${1}" "https://api.imgur.com/3/image/${2}")"
	if [ "${?}" -eq "0" ] && [ "$(jq -r .success <<<"${response}")" = "true" ]; then
		echo "Image successfully deleted (delete hash: ${2})." >> "${3}"
	else
		echo "The Image could not be deleted: ${response}." >> "${3}"
	fi
}

handle_file() {
	local img_file edit_cmd

	if [ -z "${1}" ]; then
		cd "${FILE_DIR}" || exit 1
		img_file="$(date +"${FILE_NAME_FORMAT}")"
		take_screenshot "${img_file}"
	else
		img_file="${1}"
	fi

	img_file="$(cd "$( dirname "${img_file}")" && echo "$(pwd)/$(basename "${img_file}")")"

	if [ ! -f "${img_file}" ]; then
		echo "file '${img_file}' doesn't exist !"
		exit 1
	fi

	if [ "${EDIT}" = "true" ]; then
		edit_cmd=${EDIT_COMMAND//\%img/${img_file}}
		if ! (eval "${edit_cmd}"); then
			echo "$(date +'%FT%T%z')"$'\t'"Error for image '${img_file}': command '${edit_cmd}' failed" | tee -a "${LOG_FILE}"
			notify error "Something went wrong :(" "Information has been logged"
			exit 1
		fi
	fi

	upload_image "${img_file}"

	if [ "${KEEP_FILE}" = "false" ] && [ -z "${1}" ]; then
		rm -f "${img_file}"
	fi

	echo ""
}

upload_image() {
	local title authorization album_opts response img_path del_id err_msg

	title="$(echo "${1}" | rev | cut -d "/" -f 1 | cut -d "." -f 2- | rev)"

	if [ "${LOGIN}" = "true" ]; then
		authorization="Bearer ${ACCESS_TOKEN}"
	else
		authorization="Client-ID ${CLIENT_ID}"
	fi

	if [ -n "${ALBUM_ID}" ]; then
		album_opts="-F album=${ALBUM_ID}"
	fi

	response="$(curl --compressed --connect-timeout "${UPLOAD_CONNECT_TIMEOUT}" -m "${UPLOAD_TIMEOUT}" --retry "${UPLOAD_RETRIES}" -fsSL --stderr - -H "Authorization: ${authorization}" -F "title=${title}" -F "image=@\"${1}\"" ${album_opts} https://api.imgur.com/3/image)"

	if [ "$(jq -r .success <<<"${response}" 2>/dev/null)" = "true" ]; then
		img_path="$(jq -r .data.link <<<"${response}" | cut -d / -f 3-)"
		del_id="$(jq -r .data.deletehash <<<"${response}")"

		if [ ! -z "${AUTO_DELETE}" ]; then
			export -f delete_image
			nohup /bin/bash -c "sleep ${AUTO_DELETE} && delete_image ${CLIENT_ID} ${del_id} ${LOG_FILE}" &
		fi

		handle_upload_success "https://${img_path}" "https://imgur.com/delete/${del_id}" "${1}"
	else
		err_msg="$(jq .error <<<"${response}" 2>/dev/null)"
		test -z "${err_msg}" && err_msg="${response}"
		handle_upload_error "${err_msg}" "${1}"
	fi
}

handle_upload_success() {
	local open_cmd

	echo "image  link: ${1}"
	echo "delete link: ${2}"

	if [ "${COPY_URL}" = "true" ] && [ -z "${ALBUM_TITLE}" ]; then
		echo -n "${1}" | eval "${CLIPBOARD_COMMAND}"
	fi

	echo -e "$(date +'%FT%T%z')\t${1}\t${3}\t${2}" >> "${LOG_FILE}"

	notify ok "Upload done!" "${1}"

	if [ ! -z "${OPEN_COMMAND}" ] && [ "${OPEN}" = "true" ]; then
		open_cmd=${OPEN_COMMAND//\%url/${1}}
		open_cmd=${open_cmd//\%img/${2}}
		eval "${open_cmd}"
	fi
}

handle_upload_error() {
	local error

	error="Upload failed: \"${1}\""
	echo "${error}"
	echo -e "$(date +'%FT%T%z')\tError\t${2}\t${error}" >> "${LOG_FILE}"
	notify error "Upload failed :(" "${1}"
}

create_album() {
	local err_msg del_id auth

	if [ "${LOGIN}" = "true" ]; then
		auth="Bearer ${ACCESS_TOKEN}"
	else
		auth="Client-ID ${CLIENT_ID}"
	fi

	response="$(curl -fsSL --stderr - -F "title=${ALBUM_TITLE}" -H "Authorization: ${auth}" https://api.imgur.com/3/album)"
	if [ "$(jq -r .success <<<"${response}" 2>/dev/null)" = "true" ]; then
		ALBUM_ID="$(jq -r .data.id <<<"${response}")"
		del_id="$(jq -r .data.deletehash <<<"${response}")"
		handle_album_creation_success "https://imgur.com/a/${ALBUM_ID}" "${del_id}" "${ALBUM_TITLE}"

		if [ "${LOGIN}" = "false" ]; then
			ALBUM_ID="${del_id}"
		fi
	else
		err_msg="$(jq -r .data.error <<<"${response}" 2>/dev/null)"
		test -z "${err_msg}" && err_msg="${response}"
		handle_album_creation_error "${err_msg}" "${ALBUM_TITLE}"
	fi
}

handle_album_creation_success() {
	echo "Album  link: ${1}"
	echo "Delete hash: ${2}"
	echo ""
	notify ok "Album created!" "${1}"

	if [ "${COPY_URL}" = "true" ]; then
		echo -n "${1}" | eval "${CLIPBOARD_COMMAND}"
	fi

	echo -e "$(date +'%FT%T%z')\t${1}\t\"${3}\"\t${2}" >> "${LOG_FILE}"
}

handle_album_creation_error() {
	local error

	error="Album creation failed: \"${1}\""
	echo -e "$(date +'%FT%T%z')\tError\t${2}\t${error}" >> "${LOG_FILE}"
	notify error "Album creation failed :(" "${1}"
	if [ ${EXIT_ON_ALBUM_CREATION_FAIL} ]; then
		exit 1
	fi
}

if [ "${1}" = "--debug" ]; then
	debug_mode "${@}"
	shift
fi

initialize
parse_args "${@}"
main
